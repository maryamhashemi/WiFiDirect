% !TeX root=main.tex
\chapter{روش حل مسئله و پیاده‌سازی}
\thispagestyle{empty}
\section{اتصال دستگاه‌ها  در لایه‌ی فیزیکی با استفاده از فناوری \lr{WifiDirect}}

برای اجرای خدمات لایه‌ی شبکه‌ی اجتماعی، ابتدا لازم است که دستگاه‌ها در لایه‌ی فیزیکی به یکدیگر متصل شوند و امکان ارسال و دریافت اطلاعات در لایه‌ی فیزیکی فراهم شود. به همین جهت از فناوری 
\lr{WiFi Direct}
استفاده خواهیم کرد تا شرایط لازم در لایه‌ی فیزیکی را برای ما برقرار‌کند. در ادامه‌ی این بخش توضیح خواهیم که سه مورد 
\lr{Discovery}
،
\lr{Connect}
و
\lr{Create Group}
برای برقراری ارتباط در لایه‌ی فیزیکی چگونه در
\lr{WiFi Direct}
 انجام می‌شود.
\subsection{\lr{Discovery}}
 برای برقرای ارتباط، باید بررسی کنیم که چه افرادی در نزدیکی ما حضور دارند. به این کار
\lr{Discovery}
  می‌گوییم. برای انجام 
\lr{Discovery}
در 
\lr{WiFi Direct}
کافی است از متد
\lr{discoverPeers()}
استفاده کنیم. با صدا زدن این متد،
\lr{Discovery}
آغاز می‌شود و در صورت موفقیت‌آمیز بودن، با صدا زدن متد
\lr{requestPeers()}
می‌توانیم به لیست افرادی که در نزدیکی ما هستند؛ دست پیدا کنیم و تمامی افرادی که آمادگی لازم برای برقراری ارتباط دارند را مشاهده کنیم. توجه داشته باشید که در این روش تنها افرادی را می‌توان مشاهده کرد که آن‌ها هم عملیات 
\lr{Discovery}
را انجام دهند. در غیر این صورت شما نمی‌توانید آن‌ها را در لیست خود مشاهده کنید.
\subsection{\lr{Connect}}
بعد از پیدا کردن افراد نزدیک به خودمان، باید بتوانیم به فرد مورد نظر متصل شویم. برای این کار با دانستن اطلاعات پیکربندی دستگاه مورد نظر و با استفاده از متد 
\lr{connect()}
عملیات اتصال را آغاز می‌کنیم. اگر متد 
\lr{connect()}
موفقیت آمیز باشد، با استفاده از رابط 
\lr{ConnectionInfoListener}
بررسی می‌کنیم که آیا وضعیت اتصال دستگاه فعلی تغییر کرده است یا خیر. با استفاده از متد 
\lr{onConnectionInfoAvailable()}
که رابط 
\lr{ConnectionInfoListener}
 در اختیار ما قرار می‌دهد، چک می‌کنیم که کدام یک از این دستگاه‌ها مالک گروه هست و کدام یک مشتری گروه هست. بنابراین با توجه به نقش هر دستگاه در این ارتباط نقش  
\lr{Server}
یا 
\lr{Client}
را برای آن‌ها انتخاب خواهیم کرد.
توجه شود که اطلاعات پیکربندی دستگاه شامل مواردی مانند آدرس 
\lr{MAC}
\LTRfootnote{Media Access Control} 
دستگاه و اطلاعات 
\lr{WPS} 
\LTRfootnote{Wi-Fi Protected Setup} 
می‌باشد.
\subsection{\lr{Create Group}}
در بخش قبل توضیح دادیم که چگونه می‌توانیم دو دستگاه را به یکدیگر متصل کنیم. اما اگر بخواهیم چندین دستگاه به یکدیگر متصل شوند؛ باید از متد 
\lr{createGroup() }
استفاده کنیم. در این صورت دستگاهی که این متد را صدا بزند به عنوان مالک گروه خواهد شد و هر دستگاهی که وارد این گروه شود به عنوان مشتری گروه خواهد یود. 
پس از این که این متد به صورت موفقیت‌آمیز اجرا شد؛ با فراخوانی متد
\lr{requestGroupInfo()}
می‌توانیم جزئیات بیشتری در مورد دستگاهی‌هایی که در این گروه قرار دارند مانند نام این دستگاه‌ها و وضعیت اتصال آن‌ها را درخواست بدهیم. سپس با استفاده از متد
\lr{onGroupInfoAvailable()}
که رابط 
\lr{GroupInfoListener}
در اختیار ما قرار می‌دهد؛ می‌توانیم اطلاعات مرتبط با گروه را مشاهده کنیم.
\section{دریافت و ارسال پیام}
در بخش قبل دیدیم که چگونه می‌توان با استفاده از 
\lr{WiFi Direct}
دستگاه‌ها را در لایه‌ی فیزیکی به یکدیگر متصل کرد. در این بخش می‌خواهیم با استفاده از برنامه‌نویسی 
\lr{socket}
 و از طریق دو روش 
\lr{Multi thread}
و 
\lr{Asynchronous}
این امکان را ایجاد کنیم که دستگاه‌ها با یکدیگر پیام رد و بدل کنند. بنابراین در یک ارتباط، لازم است که یکی از دستگاه‌ها در نقش
\lr{server}
 و دیگری در نقش
\lr{client}
 باشد. ما در اینجا دستگاهی که به عنوان مالک گروه باشد را 
 \lr{server}
و  دیگری را 
\lr{client}
 در نظر می‌گیریم. در ادامه‌ی این بخش وظیفه‌ی 
\lr{server}
و
\lr{client}
را در هر دو روش
 \lr{Multi thread}
و 
\lr{Asynchronous}
بیان می‌کنیم و توضیح خواهیم داد که هر کدام از چه متد‌هایی استفاده خواهند کرد.
\subsection{\lr{Multi thread} یا \lr{Synchronous}}
همانطور که از اسم این روش پیداست، در این روش، برای هر قسمت از  کاری که می‌خواهیم انجام بدهیم برای مثال اتصال، ارسال پیام و دریافت پیام و ... یک 
\lr{thread}
اختصاص می‌دهیم که همه‌ی آن‌ها به صورت همزمان در حال انجام وظیفه‌ی خودشان هستند. 
دراین روش  ما منتظر جواب از طرف مقابل هستیم و در واقع تا دریافت جواب، آن متد مسدود یا 
\lr{Block}
می‌شود. شبیه زمانی است که شما در حال مکالمه با دوستتان در پشت تلفن هستید. وقتی که شما حرفی می‌زنید، منتظر هستید تا نفر دیگر پاسخ شما را بدهد. بنابراین همین انتظار باعث می‌شود تا زمان زیادی مصرف شود و منابع ما هدر برود.

همچینین این روش به صورت دنباله‌ای متوالی انجام می‌شود. یعنی شما یک کانال برای ارتباط ایجاد می‌کنید(شماره‌ی دوستتان را می‌گیرید) و در ادامه یک سری اطلاعات را تبادل می‌کنید(شما یا دوستتان صحبت می‌کنید و منتظر جواب طرف مقابل هستید.) و در آخر هم کانال ارتباطی را می‌بندید(تلفن را قطع می‌کنید).

در این روش منابع موجود، بین 
\lr{thread}
ها به اشتراک گذاشته می‌شود. این روش برای تعداد اتصالات کم مناسب است. اما وقتی تعداد اتصالات وسیع باشد؛ دیگر نمی‌توان همه‌ی اتصالات را به صورت درست مدیریت کرد. در واقع برنامه‌ریزی
\LTRfootnote{Scheduling} 
\lr{thread}
ها سربار ایجاد خواهد کرد. زیرا تعداد‌شان زمانی که اتصالات زیاد می‌شود؛ افزایش پپدا می‌کند.

برای پیاده‌سازی این روش از سه کلاس استفاده کرده‌ایم که در ادامه هر کدام را به صورت مجزا توضیح خواهیم داد.
\subsubsection{Server}
در کلاس 
\lr{Server}
دو متد را پیاده‌سازی کردیم:
\begin{enumerate}
	\item Accept()
: در این متد 
	\lr{server}
در یک حلقه‌ی بی‌نهایت بر روی درگاه 8888 در حال گوش‌دادن به درخواست‌های 
	\lr{client}
است. بعد از آن که
	\lr{server}
درخواست یک 
	\lr{client}
را قبول می‌کند، برای این 
	\lr{client}
یک 
	\lr{ClientHandler}
می‌سازد و آن را به لیست 
	\lr{Client}
هایی که به سرور متصل هستند، اضافه می کند. متد 
	\lr{Accept()}
برای انجام همه‌ی این مراحل از یک 
	\lr{thread}
استفاده می‌کند.
	\item Send()
	:در این متد server یک پیام را برای همه‌ی 
	\lr{client}
	هایی که به آن متصل هستند؛ ارسال می‌کند. در واقع پیام را بر روی جریان خروجی داده که توسط 
	\lr{socket}
	ما بین 
	\lr{server}
	و 
	\lr{client}
	ایجاد‌شده‌است؛ قرار می‌دهد. برای انجام این کار، از یک 
	\lr{thread}
	استفاده می‌شود.
\end{enumerate}

\subsubsection{Client}
در کلاس 
\lr{Client}
سه متد را پیاده سازی کردیم:
\begin{enumerate}
	\item Connect()
	: در این متد 
	\lr{client}
	 به 
	 \lr{server}
‌ای که در حال گوش دادن بر روی درگاه 8888 هست؛ متصل می شود. به محض این که 
	\lr{socket}
	به درستی بین 
	\lr{client}
	و
	\lr{server}
	ایجاد شد، 
	\lr{client}
	با صدا زدن متد
	\lr{Receive()}
	آماده‌ی دریافت پیام از سوی 
	\lr{server}
	می‌شود. توجه شود که همه‌ی این کار‌ها توسط یک 
	\lr{thread}
	انجام می‌شود.
	\item Send()
	: در این متد 
	\lr{Client}
	پیامی را که می‌خواهد برای 
	\lr{server}
	ارسال کند را بر روی جریان خروجی داده که به کمک 
	\lr{socket}
	بین این دو ایجاد‌شده‌است، قرار می‌دهد. از یک 
	\lr{thread}
	برای ارسال پیام استفاده می‌کنیم.
	\item Receive()
	: در این متد پیامی را که 
	\lr{server}
	برای
	\lr{client}
	ارسال کرده‌است را از روی جریان ورودی داده می‌خوانیم. همانند ارسال برای دریافت هم از یک 
	\lr{thread}
	استفاده می‌کنیم.
\end{enumerate}

	\subsubsection{ClientHandler}
	هدف ما در این کلاس این است که بتوانیم 
	\lr{client}
	های متصل به 
	\lr{server}
	را مدیریت کنیم. این کلاس تنها یک متد 
	\lr{Broadcast()}
	را دارد. در این متد قرار است که 
	\lr{server}
	پیام‌هایی را که از 
	\lr{client}
	هایش دریافت می‌کند را برای سایر 
	\lr{client}
	هایش ارسال کند. کاری که دقیقا در این متد انجام می‌شود؛ این است که پیام را از جریان ورودی داده‌ی یکی از 
	\lr{client}
	هایش  می‌خواند و سپس آن را بر روی جریان خروجی داده سایر 
	\lr{client}
	هایش قرار می‌دهد. دقت شود که همه‌ی این کار‌ها توسط یک 
	\lr{thread}
	خاص اجرا می‌شود.


\subsection{\lr{Asynchronous}}
در این روش ما کار‌های لازم در شبکه را پست می‌کنیم ولی منتظر جواب نمی مانیم بلکه نتیجه را بعدا بررسی می‌کنیم. شبیه موقعی است که شما به دوستتان پیام متنی ارسال می‌کنید و منتظر جواب درهمان لحظه نمی‌مانید و جواب دوستتان ممکن است الان یا یک ساعت دیگر برسد. بنابراین جواب را بعدا چک می‌کنید. 

این روش بر خلاف روش 
\lr{synchronous}
به صورت دنباله‌ای نیست. اما دنبال کردن وضعیت هر یک از کار‌ها کمی مشکل است.
بنابراین با توجه به ویژگی‌هایی که برای این روش ذکر کردیم؛ می‌توانیم با استفاده از این روش از هدر رفتن منابع جلوگیری کنیم. همچینین می‌توانیم تعداد اتصالات بیشتری را با همان سخت افزار موجود مدیریت کنیم.

برای پیاده سازی این روش از 4 کلاس استفاده کرده‌ایم. که در ادامه هر کدام را به صورت مجزا توضیح خواهیم داد.
\subsubsection{WiFiNetService}
هدف از این کلاس این است که دستگاه چه در نقش 
\lr{client} 
و چه در نقش 
\lr{server}
باشد، بتواند 4 کار ارتباطی زیر را انجام دهد:
\begin{enumerate}
	\item ارسال پیام به یک دستگاه خاص:
	
	برای انجام این کار از متد
	\lr{Send()}
	استفاده می‌کنیم که در آن از متد 
	\lr{StartWrite()}
	استفاده شده است که بوسیله ی آن می‌توان پیام را بر روی بافر دستگاه مورد نظر قرار داد. چون نوشتن بر روی بافر، یک عمل ناهمزمان است از
	\lr{CompletionHandler}
	استفاده می‌کنیم که کامل شدن یا شکست خوردن را به 
	\lr{thread}
	اصلی اعلام کند.
	\item دریافت پیام از یک دستگاه خاص:
	
	برای انجام این کار از متد
	\lr{Receive()}
	استفاده می‌کنیم که در آن از متد
	\lr{StartRead()}
	استفاده شده‌است که بوسیله‌ی آن می‌توان پیام را از بافر دستگاه مورد نظر خواند. چون خواندن از روی بافر یک عمل ناهمزمان است از 
	\lr{CompletionHandler}
	استفاده می‌کنیم که کامل شدن یا شکست خوردن را به 
	\lr{thread}
	اصلی اعلام می‌کند.
	
	\item ارسال پیام به تمامی دستگاه‌هایی که به دستگاه فعلی متصل هستند:

برای انجام این کار از متد
\lr{Broadcast()}
استفاده می‌کنیم که در آن پیام بر روی بافر همه‌ی دستگاه‌هایی که به دستگاه فعلی متصل هستند؛ قرار‌داده می‌شود. این عمل نیز به صورت ناهمزمان اجرا می‌شود.

	\item ارسال پیام دریافت شده به تمامی دستگاه‌هایی که به دستگاه فعلی متصل هستند:
	
	برای انجام این کار از متد
	\lr{ReceiveBroadcast()}
	استفاده می‌کنیم که پس از دریافت یک پیام آن را بر روی بافر تمامی دستگاه‌های متصل به دستگاه فعلی قرار می‌دهیم. این عمل هم به صورت ناهمزمان اجرا می‌شود.
	
\end{enumerate}
\subsubsection{Device}
هدف از ایجاد این کلاس این است که برای هر دستگاه یک کانال ناهمزمان 
\lr{socket}
برای رد و بدل پیام در نظر بگیریم. و همچنین اطلاعات دیگری نظیر اسم دستگاه را نگهداری کنیم.
\subsubsection{Server}
این کلاس تنها یک متد
\lr{Start()}
 دارد که با صدا زدن آن 
\lr{server}
 در یک حلقه‌ی بی نهایت بر روی درگاه 8888 شروع به گوش دادن به درخواست  از طرف 
\lr{client}
 ها می‌کند. اما این کار باعث انسداد یا 
\lr{Blocking}
نمی‌شود. بلکه به صورت ناهمزمان انجام می‌شود. بنابراین از یک 
\lr{CompletionHandler}
استفاده کرده‌ایم. که در صورتی که یک 
\lr{client}
به 
\lr{server}
متصل شود و عمل کامل شود؛ سرور متد 
\lr{ReceiveBroadcast()}
را از کلاس 
\lr{WiFiNetService}
فراخوانی می‌کند و آماده‌ی دریافت پیام از یکی از 
\lr{client}
هایش می‌شود و سپس آن را برای تمامی دستگاه‌های متصل، ارسال می‌کند.

\subsubsection{Client}
این کلاس همانند کلاس 
\lr{Server}
تنها یک متد
\lr{Start()}
 دارد که با فراخوانی آن دستگاه به 
\lr{server}
ای که بر روی درگاه 8888 در حال گوش دادن هست، متصل می‌شود. این عمل نیز به صورت ناهمزمان انجام می‌شود. بنابراین از یک
\lr{CompletionHandler}
استفاده کرده‌ایم و در صورت کامل شدن اتصال، دستگاه با فراخوانی متد
\lr{Receive()}
از کلاس 
\lr{WiFiNetService}
آماده‌ی دریافت پیام می‌شود.

\section{جمع بندی}
در این فصل بیان کردیم که چگونه دو دستگاه یا چندین دستگاه می‌توانند در لایه‌ی فیزیکی با استفاده از فناوری 
\lr{WiFiDirect}
هم دیگر را پیدا کنند و بهم متصل شوند.
همچنین در ادامه مشاهده کردیم که چگونه دستگاه‌ها می‌توانند با استفاده از برنامه‌نویسی
\lr{Socket}
 با دو روش 
 \lr{Multi thread}
 و
 \lr{Asynchronous}
 پیام ارسال و دریافت کنند. با توجه به ویژگی‌های هر کدام از این دو روش به این نتیجه رسیده‌ایم که زمانی که تعداد اتصالات زیاد می‌شود؛ روش 
 \lr{Asynchronous}
 روش بهتری است.





